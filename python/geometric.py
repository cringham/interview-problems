import random
import math


# O(n^2)
def count_geo_seq_ratio_one(sequence):
    tuple_count = 0

    previous_unique_term = None
    for comparison_term in sequence:
        if comparison_term == previous_unique_term:
            pass
        else:
            term_count = 0
            for term in sequence:
                if term == comparison_term:
                    term_count += 1
            combinations = math.factorial(term_count) / (math.factorial(term_count - 3) * 6)  # C(n, r) = n! / ((n - r)! * r!)
            tuple_count += combinations
        previous_unique_term = comparison_term

    return tuple_count


# O(n^3)
def count_geo_seq_unsorted(sequence, ratio):
    tuple_count = 0

    for term3_index in range(len(sequence)-1, -1, -1):
        # If a large value causes float division overflow, use integer division
        try:
            term3 = sequence[term3_index]
            term2 = term3 / ratio
            term1 = term2 / ratio
        except OverflowError:
            term3 = sequence[term3_index]
            term2 = term3 // ratio
            term1 = term2 // ratio

        for comp_term2_index in range(len(sequence)-1, -1, -1):
            comp_term2 = sequence[comp_term2_index]
            if comp_term2 == term2 and comp_term2_index < term3_index:
                for comp_term1_index in range(len(sequence)-1, -1, -1):
                    comp_term1 = sequence[comp_term1_index]
                    if comp_term1 == term1 and comp_term1_index < comp_term2_index:
                        tuple_count += 1

    return tuple_count


# O(n^3)
def count_geo_seq(sequence, ratio):
    tuple_count = 0

    if sequence != sorted(sequence):
        return count_geo_seq_unsorted(sequence, ratio)

    if ratio == 1:
        return count_geo_seq_ratio_one(sequence)

    for term3_index in range(len(sequence)-1, -1, -1):
        # If a large value causes float division overflow, use integer division
        try:
            term3 = sequence[term3_index]
            term2 = term3 / ratio
            term1 = term2 / ratio
        except OverflowError:
            term3 = sequence[term3_index]
            term2 = term3 // ratio
            term1 = term2 // ratio

        term2_count = 0
        term1_count = 0
        for term in sequence:
            if term == term2:
                term2_count += 1
            elif term == term1:
                term1_count += 1

        tuple_count = tuple_count + (term2_count * term1_count)

    return tuple_count


def construct_test_cases(unsorted=False):
    """
    This function constructs the set of test cases used to test the geo_seq function.
    The initial set contains short, sorted lists, with the long case dynamically generated and added on.
    If the unsorted parameter is set to True, the test_cases will also contains unsorted lists (for Part B)
    """

    # initial sorted cases
    test_cases = [
        ([1, 2, 2, 4], 2, 2),
        ([1, 1, 5, 25, 25, 125, 625], 5, 8),
        ([125, 125, 25, 25, 5], 5, 0),
        ([1, 3, 9, 9, 9, 9, 9, 10, 27, 81], 3, 15),
        ([345]*10000, 1, 166616670000),
        ([1, 1, 1, 1] + [3, 3, 3, 3], 1, 8),
    ]

    # unsorted cases
    if unsorted:
        test_cases += [
        ([1, 3, 9, 9, 9, 9, 9, 10, 9, 27, 81], 3, 18),
        ([1, 3, 9, 9, 9, 4, 9, 9, 10, 12, 27, 81, 36, 81], 3, 21),
        ([4, 2, 1], .5, 1),
        ([1, 3, 9, 1, 3, 9], 3, 4),
        ([4, 2, 1, 4, 2, 1], .5, 4),
        ([1, 3, 9, 1, 1, 3, 9, 3], 3, 5),
        ([1, 3, 9, 1, 1, 3, 9, 3, 9], 3, 12),
        ([4, 2, 2, 1], .5, 2),
        ([1, -3, 9], -3, 1),
        ([1, -3, 9, 9, -27, 27], -3, 4),
        ([-4, 2, 2, -1], -.5, 2)
    ]

    # one long case, dynamically generated by incrementing powers of four and inserting a random number of each into the list
    long_case = []
    count = 0
    prev = 0
    prev_prev = 0
    for n in range(0, 10000):
        rand_count = random.randrange(4)
        count += prev_prev * prev * rand_count
        prev_prev = prev
        prev = rand_count
        for i in range(rand_count):
            long_case.append(4**n)

    test_cases.append((long_case, 4, count))

    return test_cases


for case in construct_test_cases(unsorted=True):
    l, r, output = case
    print(count_geo_seq(l, r) == output)
